**Devlog #5 -- Cell Access :: (12/7/2025)**
I saw that I needed real coordinates, so I decided to index the map instead of only scanning the rows. I tried using nth at first, but Prolog raised an error because the correct built-in is nth0. That told me that the best way to read a cell 
is to write a helper that takes a row index and column index. I added a small predicate that returns a cell value based on its position and tested it on a known map. This showed me the right coordinates and confirmed that indexing works. I still 
do not have full map validation yet, but I now have a way to extract real positions. My next idea is to use findall on this helper so I can locate the start and exit in the map.

**Devlog #4 -- Map Start :: (12/7/2025)**
My first idea for validating the map was simple. I tried to look through the rows with member and check if any row contained s or e. This worked in the sense that it ran, but the output gave me fixed coordinates like (0,0) and (1,1), 
which were wrong. The test also produced a second result of false which told me that the logic was loose and did not enforce uniqueness. I realised that this method has no way to track the real position of each cell. I also saw that it 
does not check shape or cell types. I think the next step is to use indexed access so I can recover the actual row and column for each symbol.

**Devlog #3 -- Getting Ready to Code :: (12/7/2025)**
I created a new file project.pl in the same folder as example.pl and test.pl all of which I got True when I checked on whether or not I have imported it correctly.
I wrote a minimal version of find_exit to check that the file loads which they do. 

I also wrote the command: 
?- basic_map(M), display_map(M), find_exit(M, A).

And it gave me:
find_exit not implemented yet
false.

So find_exit ran, printed the line and failed, which is what I wanted at that stage. 
Now I am going to continue adding more code and keep testing along the way to make sure that everything is running as it should. 

**Devlog #2 -- Pseudocoded :: (12/7/2025)**
Before I code, I write down my planned structure in pseudocode. I want the logic to stay clear in my head. In my pseudocoded I decide to use depth first search because it is simple in Prolog. A shortest path is not required, only a valid path.
Now I am going to go ahead and start implementing this in prolog.

**Devlog #1 -- Idea planning / First look at the project:: (12/7/2025)**
I start the project by opening the two given files, example.pl and test.pl. example.pl has a few small maps and a display_map/1 predicate. test.pl has a random maze generator and its own display function. The instructions say that I must write 
find_exit/2. The predicate should take a map and either return a path, or check a given path. It should also reject bad maps. At this point I try to understand the representation.  The map is a list of rows. Each row is a list of symbols. 
The symbols are w for wall, f for free, s for start, and e for exit. The assignment wants me to use these maps, not create my own. So I decide that I will not change example.pl or test.pl. I will just create a new file, project.pl, with my own predicates.

I start thinking about the tasks. First I need to check to see that whether or not a map is valid. Find the coordinates of s and e. Walk through the maze using moves up, down, left, and right. Explore the maze to find a path. If the user gives a path, 
follow it and check if it reaches the exit.I decide to split the work in that order. First I will validate maps, then I will follow a path, then I will search for one.

Before I even get started on the actual code in prolog I am going to write some pseudocode to guide my ideas better.
