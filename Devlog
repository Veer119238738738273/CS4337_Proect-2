**Devlog #9 -- Visited Lists :: (12/7/2025)**
The infinite loop in my first DFS attempt showed me that I needed a way to stop the search from revisiting the same coordinates. I added a visited list to record every position reached during the search. I also changed the DFS structure so it builds a path 
in reverse. This version ran without the stack overflow I saw before. I tested it on the basic map and it produced a clear and simple path. With this change the search became stable and ready for use in find_exit.

**Devlog #8 -- First Search :: (12/7/2025)**
I started working on the path search and wrote a simple version of DFS that moved through the grid. I did not track visited cells in this first attempt and the search kept looping in circles. When I tested my code on a small map, Prolog did not return a result 
and I had to stop the program. This showed me that the maze allows moves that lead back to earlier positions and DFS will explore them forever. I understood then that I needed a list of visited coordinates to stop the recursion from repeating. I planned to 
rewrite the search to carry an accumulator for moves and another list for visited cells. This change should keep the search stable and allow it to reach the exit.

**Devlog #7 -- Updated Validation (Valid_Map) :: (12/7/2025)**
I replaced my first version of valid_map because it did not use coordinates and it did not enforce the rules of the project. The earlier version only checked if some row contained s or e and then returned fixed coordinates which were wrong. I decided to use my 
cell_at helper with findall to gather all coordinates of both symbols. This let me check that there is exactly one start and one exit. I also added the rectangular and valid-cell checks to keep the structure sound. After these changes, the validation became 
predictable and stable. I tested it on both good and bad maps and the results matched what I expected.

**Devlog #6 -- Shape Check :: (12/7/2025)**
I knew that a valid map must be rectangular, so I started by checking the length of the first row. My first idea was to use length inside maplist, but I wrote the arguments in the wrong order and Prolog raised an instantiation error. That showed me I needed 
a predicate that compares row lengths in a cleaner way. I replaced my first attempt with same_length(Row) which kept the code simple. This worked better and Prolog no longer complained. I also added a rule to ensure every cell belongs to the allowed set. 
These checks do not find the start or exit yet, but they give me a proper structure to build on.

**Devlog #5 -- Cell Access :: (12/7/2025)**
I saw that I needed real coordinates, so I decided to index the map instead of only scanning the rows. I tried using nth at first, but Prolog raised an error because the correct built-in is nth0. That told me that the best way to read a cell 
is to write a helper that takes a row index and column index. I added a small predicate that returns a cell value based on its position and tested it on a known map. This showed me the right coordinates and confirmed that indexing works. I still 
do not have full map validation yet, but I now have a way to extract real positions. My next idea is to use findall on this helper so I can locate the start and exit in the map.

**Devlog #4 -- Map Start :: (12/7/2025)**
My first idea for validating the map was simple. I tried to look through the rows with member and check if any row contained s or e. This worked in the sense that it ran, but the output gave me fixed coordinates like (0,0) and (1,1), 
which were wrong. The test also produced a second result of false which told me that the logic was loose and did not enforce uniqueness. I realised that this method has no way to track the real position of each cell. I also saw that it 
does not check shape or cell types. I think the next step is to use indexed access so I can recover the actual row and column for each symbol.

**Devlog #3 -- Getting Ready to Code :: (12/7/2025)**
I created a new file project.pl in the same folder as example.pl and test.pl all of which I got True when I checked on whether or not I have imported it correctly.
I wrote a minimal version of find_exit to check that the file loads which they do. 

I also wrote the command: 
?- basic_map(M), display_map(M), find_exit(M, A).

And it gave me:
find_exit not implemented yet
false.

So find_exit ran, printed the line and failed, which is what I wanted at that stage. 
Now I am going to continue adding more code and keep testing along the way to make sure that everything is running as it should. 

**Devlog #2 -- Pseudocoded :: (12/7/2025)**
Before I code, I write down my planned structure in pseudocode. I want the logic to stay clear in my head. In my pseudocoded I decide to use depth first search because it is simple in Prolog. A shortest path is not required, only a valid path.
Now I am going to go ahead and start implementing this in prolog.

**Devlog #1 -- Idea planning / First look at the project:: (12/7/2025)**
I start the project by opening the two given files, example.pl and test.pl. example.pl has a few small maps and a display_map/1 predicate. test.pl has a random maze generator and its own display function. The instructions say that I must write 
find_exit/2. The predicate should take a map and either return a path, or check a given path. It should also reject bad maps. At this point I try to understand the representation.  The map is a list of rows. Each row is a list of symbols. 
The symbols are w for wall, f for free, s for start, and e for exit. The assignment wants me to use these maps, not create my own. So I decide that I will not change example.pl or test.pl. I will just create a new file, project.pl, with my own predicates.

I start thinking about the tasks. First I need to check to see that whether or not a map is valid. Find the coordinates of s and e. Walk through the maze using moves up, down, left, and right. Explore the maze to find a path. If the user gives a path, 
follow it and check if it reaches the exit.I decide to split the work in that order. First I will validate maps, then I will follow a path, then I will search for one.

Before I even get started on the actual code in prolog I am going to write some pseudocode to guide my ideas better.
